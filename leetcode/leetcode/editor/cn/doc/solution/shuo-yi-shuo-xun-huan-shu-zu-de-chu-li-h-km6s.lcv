看了几个大佬的解答算是理解了：
第一个点：整体思路
- 数组最后肯定是变成某个一样的数字，这个数字其实是有限的，肯定是数组中的一个
- 我们可以计算，所有可以变成的数字时需要的用时，这样我们找到需要的最小用时就可以了， 比如：nums = [1,2,1,2]， 我们可以计算都变成1耗时耗时多少，都变成2耗时多少，较小耗时就是答案

第二个点：如何计算都变成某个数字的耗时
如： x x 1 x x 1 x x 1 x x x x
1、需要计算俩个1之间的部分都变成1的耗时：可以算出来是：（j - i）  / 2

* 

~~~
1 1 -> 0
1 x 1 -> 1
1 x x 1 - > 1
1 x x x 1 - > 2
i       j
~~~

2、需要考虑最走边的1和最右边的1，因为左、右边的1像俩边扩展的时候，如果到头部/末尾了是可以继续跳转到末尾/头部继续扩张的，
计算思路是把左面1的前面部分（包括1）移动到末尾，也就相当于把 i 移动到 i + n(所以代码中需要push v[0] + n)，然后采用上面的计算方法即可

* 

~~~
1 x 1 -> 0
1 x 1 x -> 1 : 相当于 x 1 x 1
|...........................|
x 1 x 1 x - > 1 : 相当于 x 1 x x 1
|..............................|
~~~

---

* 

~~~

public:
    int minimumSeconds(vector<int>& nums) {
        // 使用hash记录每个个数字的位置
        unordered_map<int, vector<int>> umap;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            umap[nums[i]].push_back(i);
        }
        int res = INT_MAX;
        // 循环遍历，最终变成每个数字的时候需要的时间
        for (auto &[k, v] : umap) {
            int mx = -1;
            v.push_back(v[0] + n);
            for (int i = 0; i < v.size() - 1; i++) {
                int tmp = (v[i + 1] - v[i]) / 2;
                mx = max(mx, tmp);
            }  
            res = min(res, mx);
        }
        return res;
    }
};
~~~

